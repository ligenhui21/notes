java虚拟机根据**类名**、**方法名**和**方法描述符**来识别方法。方法描述符由**参数类型**和**返回值类型**构成。

### 重载

java程序中如果多个方法的方法名相同并且参数列表不同，将构成重载，子类和父类中的方法同样会构成重载。但是虚拟机并不限制方法名和参数相同，返回值不同的方法出现在同一个类中。

重载的方法在编译期间即可完成识别，编译器会根据参数的**声明类型**来选取重载方法。选取的过程分为以下几个阶段：

1. 在不考虑基本类型的自动转换、自动拆装箱和可变长参数的情况下选取方法。
2. 如果在第一阶段未找到适配的方法，考虑基本类型的自动转换来选取方法。

   - byte—>short—>int—>long—>float—>double 
   - char—>int
3. 如果在第二阶段未找到适配的方法，考虑自动拆装箱来选取方法。
4. 如果在第三阶段未找到适配的方法，考虑父类类型或实现的接口来选取方法。
5. 如果在第三阶段为找到适配的方法，考虑可变长参数来选取方法。

如果编译器在同一个阶段找到了多个适配的方法，那么会选取其中最贴切的方法，优先级同上面的查找步骤。

### 重写

如果子类中存在和父类中方法名相同、参数相同的非私有实例方法，那么子类中的方法重写父类中的方法；如果方法都是静态的，那么子类中的方法隐藏了父类中的方法。（子类和父类中同名的方法必须同时是实例方法或静态方法，否则不能通过编译）

虚拟机关于重写的判断同样根据类名、方法名和方法描述符。子类和父类中同名的非私有实例方法，只有当参数列表和返回值都相同的时候才构成重写。

重写需要在运行时根据调用者的动态类型来识别方法。

### 静态绑定和动态绑定

- 静态绑定：指的是在解析时便能识别目标方法的情况。
- 动态绑定：指的是在运行时根据调用者的动态类型来识别目标方法的情况。

由于重载的方法可能被子类中的方法重写，所以java虚拟机会将所有对非私有实例方法的调用编译为动态绑定的类型。

### 方法调用的字节码指令

- invokestatic：调用静态方法
- invokespecial：调用私有实例方法、构造器、父类的实例方法和构造器、所实现接口的默认方法
- invokevirtual：调用非私有实例方法
- invokeinterface：调用接口的方法
- invokedynamic：调用动态方法

### 方法调用的符号引用解析

- 非接口符号引用（假定该符号引用指向的类为C）
  1. 在C中查找符合方法名及方法描述符的方法。
  2. 如果在C中未找到，在C的父类中查找直至Object类。
  3. 如果在C的父类中未找到，在C实现的接口中查找。

- 接口符号引用（假定该符号引用指向的接口为I）
  1. 在I中查找符合方法名及方法描述符的方法。
  2. 如果在I中没找到，在Object类中查找。
  3. 如果在Object类中未找到，在父接口中查找。

经过解析后，符号引用会被解析成实际引用。对于可以静态绑定的方法而言，实际引用是一个指向方法的指针；对于需要动态绑定的方法而言，实际引用是一个方法表中的索引。



