### java代码为什么要在虚拟机里运行？
- 虚拟机提供了可移植性，编译后的java代码可以运行在不同平台的虚拟机中。
- 虚拟机提供了一个托管环境，替我们处理容易出错的部分，比如自动内存管理和垃圾回收。

### java虚拟机是怎样运行java代码的？
1. 首先编译器会将java代码编译成class文件。
2. 运行的时候虚拟机需要将class文件加载进来，加载后的java类会被放在方法区中，实际运行的时候，会执行方法区中的代码。
3. java程序最初是使用解释器解释运行的，当虚拟机发现部分方法或代码块频繁执行时，会使用即时编译器将热点代码以方法为单位编译成平台相关的机器码，之后再执行热点代码的时候就使用及时编译器编译过的代码。

### 解释执行和编译执行的比较
即时编译器编译过的代码执行效率比解释执行高，但是解释执行无需等待编译并且比较节约内存。

### 即时编译器的种类
为了在编译时间和生成代码的执行效率之间进行取舍，HotSpot引入了多个即时编译器。
- **C1编译器**（client compiler）：将字节码编译成平台相关的机器码，进行简单、可靠的优化。
- **C2编译器**（server compiler）：将字节码编译成平台相关的机器码，进行耗时较长的优化，甚至会根据运行信息进行一些不可靠的激进优化。

### 分层编译
从java7开始，HotSpot默认使用分层编译，热点代码首先会被C1编译器编译，而后会进一步被C2编译器编译。为了不干扰应用的正常运行，HotSpot的即时编译器是放在额外的线程中进行的，HotSpot会根据CPU的数量设置编译线程的数量，并且按照1：2的比例分配给C1编译器和C2编译器。

### 即时编译的对象
- 多次调用的方法
- 多次执行的循环体

虽然第二种是由于多次执行的循环体触发的，但还是以方法为单位编译。

### 热点探测
- **基于采样的热点探测**：周期性的检查栈顶，如果发现某个方法经常出现在栈顶，则视为热点方法。这种方法实现起来简单，也容易获得方法的调用关系。但是结果探测结果不准确，容易受到线程阻塞等外部原因影响。
- **基于计数器的热点探测**：通过为每个方法建立计数器，统计方法的执行次数，如果超过了阈值，则认为是热点方法。这种方法实现起来相对复杂，但是结果相对更准确。HotSpot就是采用基于计数器的热点探测方法。

### HotSpot的热点探测
HotSpot会为每个方法建立两个计数器。
- **方法调用计数器**：统计方法被调用的次数

  一个方法被调用的时候，会先判断这个方法是否有被编译过，如果有，则执行编译过的机器码；否则将这个方法的方法计数器加一，然后判断方法计数器和回边计数器的和是否超过方法计数器的阈值，如果超过，会向即时编译器发起一个该方法的编译请求。接着以解释执行的方式执行该方法，等即时编译器编译完成，这个方法的调用入口就会被换成新的，下一次被调用的时候就会使用编译过的代码。

  超过一定时间，该方法的调用次数还不足以发起即时编译的请求，方法计数器的值会减半，这叫做**热度衰减**，而这段时间成为此方法统计的**半衰周期**，进行热度衰减的动作是在垃圾回收的时候顺便进行的。


- **回边计数器**：统计循环体的执行次数

  在字节码中遇到控制流先后跳转的指令称为“回边”。

  当解释器遇到一条回边指令时，会先查找要执行的代码段是否有已经编译好的版本，如果有就执行编译过的代码，否则将回边计数器加一，然后判断回边计数器和方法调用计数器的和是否超过回边计数器的阈值，当超过时，将会提交一个OSR编译请求，并且将回边计数器的值调低一点，以便继续在解释器中执行，等待编译器输出编译结果。