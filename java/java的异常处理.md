### java的异常分类

java中的所有异常对象都是Throwable类或者子类的实例。Throwable有两大直接子类：

- **Error**：java运行时系统的内部错误和资源耗尽错误，程序无法处理也不应该抛出这种错误。
- **Exception**：程序需要捕获或者抛出的异常。
  - **RuntimeException**：由于程序错误导致的异常。
  - **非RuntimeException**：程序本身没有问题，由于外部原因导致的异常。

RuntimeException和Error属于**unchecked异常**，其他异常属于**checked异常**。所有的checked的异常都需要被显式的捕获或抛出。如果异常没有在任何地方捕获，那么程序将终止执行。

异常实例的构造十分昂贵。由于在构造异常实例的时候，java虚拟机需要生成该异常的stack trace。该操作会逐一访问当前线程的java栈帧，并且记录下各种调试信息，比如方法名，方法所在的类名、文件名以及触发异常的行号。

### java虚拟机是如何捕获异常的

在编译生成的字节码中，方法表中有一个异常表。异常表的每个条目代表一个异常处理器，由from指针、to指针、target指针和所捕获的异常类型构成。其中from指针和to指针指示了该异常处理器的监控范围，例如try代码块的范围，target指针指向异常处理器的起始位置，例如catch块的起始位置。

当程序出现异常时，会从上至下遍历异常表。当触发异常的字节码在某个异常处理器的监控范围内，java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配，如果匹配，java虚拟机将控制流转移至该条目target指向的字节码。如果未找到匹配的异常处理器，那么它会弹出当前栈帧，在调用者中重复查找合适的异常处理器。

### 为什么finally块一定会执行

当前编译器会将finally块中的内容复制到所有try-catch块的正常执行路径和异常执行路径的出口。