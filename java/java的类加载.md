java的类加载包括三个阶段：**加载**、**链接**、**初始化**。链接又分为**验证**、**准备**、**解析**三个阶段。这几个阶段是按部就班的开始，这些阶段通常是交叉进行的。

### 加载

通过类加载器将字节流加载到JVM内部，存储在方法区中，生成代表该类的java.lang.Class对象。数组类没有对应的字节流，由虚拟机直接生成。class文件是最常见的字节流。

##### 几种重要的类加载器：

- **boot class loader（启动类加载器）**

  是所有类加载器的父类加载器，用c++实现，没有对应的java对象。启动类加载器用于加载最重要、最基础的类，比如jre中lib包下的class文件。除了启动类加载器，其他的类加载器都是java.lang.ClassLoader的子类。

- **extension class loader（扩展类加载器）**

  扩展类加载器的父类加载器是启动类加载器，用于加载相对次要，但又通用的类，比如jre的lib包下的ext包中的类。java9更名为platform class loader。

- **application class loader（应用类加载器）**

  应用类加载器的父类加载器是扩展类加载器，用于加载应用程序路径下的类，比如classpath路径下的类、环境变量CLASSPATH所指定路径下的类。

类加载器除了加载类的功能之外，还有命名空间的作用。在java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即时同一个字节流，由不同的类加载器加载，也会得到两个不同的类。

##### 双亲委派模型

每当类加载器收到加载请求时，会先将请求交给父类加载器，如果父类加载器找不到要加载的字节流时，该类加载器才会尝试加载。

### 链接

链接是使创建的类能够执行的过程。

#### 验证

确保加载的类是否符合虚拟机的要求。验证阶段会完成四个阶段的检验：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. **文件格式检验**

   第一个阶段要验证字节流是否符合Class文件格式的规范，并且是否能被当前版本的虚拟机处理。这一阶段可能包含以下内容：

   - 是否以魔数0xCAFEBABE开头

   - 主、次版本号是否在当前虚拟机处理范围之内

   - 常量池中的常量是否有不被支持的常量类型（检查常量tag标志）

   - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量

     ......

   这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会直接操作字节流。

2. **元数据检验**

   第二阶段主要是对类的元数据信息进行语义检验，保证不存在不符合java语言规范的元数据信息。这个阶段可能包含的验证如下：

   - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）
   - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
   - 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
   - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数一致，返回类型不同）

3. **字节码检验**

4. **符号引用检验**

   最后一个阶段的验证发生在虚拟机将符号引用转化为直接引用的时候。通常需要校验的内容有：

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类
   - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
   - 符号引用中的类、字段、方法的访问性是否可被当前类访问

#### 准备

- 为静态变量（类变量）分配内存并设置初始值。
- 构造与该类相关联的方法表。

#### 解析

将类中的符号引用替换为实际引用。如果符号引用指向一个未被加载的类，那么将会触发这个类的加载，但未必触发这个类的链接和初始化。

java虚拟机并没有规定在链接过程中完成解析，仅规定了如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成符号引用的解析。

### 初始化

初始化阶段就是为标记为常量值得字段赋值，并执行<clinit>方法的过程。

如果直接赋值的静态变量被final所修饰，并且是基本类型或字符串，那么该变量会被编译器标记成常量值（ConstantValue），其初始化直接由虚拟机完成。

对静态变量的赋值操作，以及静态代码块中的代码，将会被编译器置于<clinit>方法中。

##### 初始化的时机：

1. 虚拟机启动时，初始化主类。

2. 遇到new指令创建对象时，初始化new指令的目标类。

3. 引用静态变量时，初始化静态变量所属的类。

4. 调用静态方法时，初始化静态方法所属的类。

5. 子类的初始化会触发父类的初始化（子接口的初始化并不会触发父接口的初始化，在使用到父接口的时候才会初始化，如引用父接口定义的常量）。

6. 如果一个接口定义了default方法，那么实现该接口的类的初始化会触发该接口的初始化。

7. 使用反射API对类进行反射调用时，初始化该类。

8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。







